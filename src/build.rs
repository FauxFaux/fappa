use std::fs;
use std::io::Write;

use failure::Error;
use fs_extra::dir;
use shiplift::rep::ContainerCreateInfo;
use shiplift::BuildOptions;
use shiplift::ContainerOptions;
use shiplift::Docker;
use tempdir;

use specs::Command;
use specs::Package;
use Release;

enum Kind {
    Modified,
    Added,
    Deleted,
}

impl From<u64> for Kind {
    fn from(val: u64) -> Self {
        match val {
            0 => Kind::Modified,
            1 => Kind::Added,
            2 => Kind::Deleted,
            other => panic!("invalid change kind: {}", other),
        }
    }
}

pub fn build(docker: &Docker, release: &Release, package: &Package) -> Result<(), Error> {
    let dir = tempdir::TempDir::new("fappa")?;
    {
        let mut dockerfile = dir.path().to_path_buf();
        dockerfile.push("Dockerfile");
        let mut dockerfile = fs::File::create(dockerfile)?;

        writeln!(dockerfile, "FROM fappa-{}", release.codename())?;
        writeln!(dockerfile, "WORKDIR /build")?;

        if !package.build_dep.is_empty() {
            writeln!(
                dockerfile,
                "RUN DEBIAN_FRONTEND=noninteractive apt-get install -y {}",
                sorted_spaced(&package.build_dep),
            )?;
        }

        for command in &package.source {
            match command {
                Command::Clone { repo, dest } => {
                    let ::git::LocalRepo { specifier, path } = ::git::check_cloned(repo)?;

                    dir::copy(format!(".cache/{}", path), &dir, &dir::CopyOptions::new())?;
                    writeln!(dockerfile, "COPY {} /repo/{}", path, path)?;
                    writeln!(
                        dockerfile,
                        "RUN git clone --no-checkout /repo/{} {} && (cd {} && git {})",
                        path,
                        dest,
                        dest,
                        specifier.git_args()
                    )?
                }
                _ => unimplemented!("source: {:?}", command),
            }
        }

        for command in &package.build {
            match command {
                Command::WorkDir(dir) => writeln!(dockerfile, "WORKDIR {}", dir)?,
                Command::Autoreconf => writeln!(
                    dockerfile,
                    "RUN autoreconf -fvi && ./configure --prefix=/usr/local && make -j 2"
                )?,
                _ => unimplemented!("build: {:?}", command),
            }
        }

        for command in &package.install {
            match command {
                Command::Run(what) => writeln!(dockerfile, "CMD {}", what)?,
                _ => unimplemented!("install: {:?}", command),
            }
        }
    }

    let built_id = ::dump_lines(
        *release,
        docker.images().build(
            &BuildOptions::builder(::tempdir_as_bad_str(&dir)?)
                .network_mode("mope")
                .build(),
        )?,
    )?
    .ok_or_else(|| format_err!("build didn't build an id"))?;

    let containers = docker.containers();

    let ContainerCreateInfo { Id: id, .. } =
        containers.create(&ContainerOptions::builder(&built_id).build())?;

    println!("starting install container {}", id);
    let created = containers.get(&id);
    created.start()?;
    created.wait()?;
    println!("done!");

    let mut new = Vec::new();
    let mut rm = Vec::new();

    for change in created.changes()? {
        match change.Kind.into() {
            Kind::Modified | Kind::Added => new.push(change.Path),
            Kind::Deleted => rm.push(change.Path),
        }
    }

    // TODO: Hmm, no. Modified and Added are not the same. We need to ensure that only
    // TODO: directories are modified, and that they're in ignorable attributes?

    // should really be a list of everything that's in the tagged image?
    let existing_files = ["/usr", "/usr/local", "/build"];

    rm.retain(|path| !matches(path, &package.exclude_files));

    ensure!(
        rm.is_empty(),
        "some files were removed, and they are not excluded: {:?}",
        rm
    );

    new.retain(|path| {
        !existing_files.contains(&path.as_str()) && !matches(path, &package.exclude_files)
    });
    {
        let violations: Vec<&String> = new
            .iter()
            .filter(|path| !matches(path, &package.include_files))
            .collect();
        ensure!(
            violations.is_empty(),
            "some files were generated by not included: {:?}",
            violations
        );
    }

    for line in new {
        println!("{}", line);
    }

    Ok(())
}

fn matches(path: &str, patterns: &[String]) -> bool {
    for pattern in patterns {
        if pattern.ends_with("/**") {
            let pattern = pattern.trim_right_matches('*');
            assert!(
                !pattern.contains(|c: char| c == '*' || '?' == c),
                "unsupported pattern extra wildcards: {}",
                pattern
            );
            if path.starts_with(pattern) {
                return true;
            }
        } else {
            unimplemented!("unsupported pattern type: {}", pattern)
        }
    }

    false
}

fn sorted_spaced<S: AsRef<str>, T: IntoIterator<Item = S>>(list: T) -> String {
    let mut vec: Vec<String> = list.into_iter().map(|x| x.as_ref().to_string()).collect();
    vec.sort();
    vec.join(" ")
}
